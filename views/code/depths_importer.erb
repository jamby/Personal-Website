<img class="displayed" src="../../../images/code_dimporter.png">
<p></p>
<p>This is The Depth's Importer. What it does is since the Maya exporter exports all of the models information in a random order, this would reorder it by the mesh. At the end, it would have successfully reordered the different types of models so they're all in contiguity.</p>
<p>The importer would first read in the amount of objects that are being exported. In the following for-loop, it would then read the size and actual characters of the mesh's name. This would be essential for finding out if this mesh was already known so it could just import its actual model data.</p>
<p>If it was a new type of mesh, it would put the actual file name of the mesh into the meshesImported vector. It would then get the transforms and put them into a vector to keep track of all the matrices that come from the same mesh.If it wasn't a new type of mesh, it would just take all of the transform matrices and put them into the vector that kept track of the mesh matrices.</p>
<p>After that, it would import the Bezier curve points throughout the level, since it was a rail shooter, the camera/player needed to follow a path and the Bezier curve points helped with that.</p>
<p>Finally it would get to the actual transform matrices that would go back to the final game's transform matrices. It would order them into one giant vector based on the the same meshes being contiguous and different ones not being in between of the ones that are the same.</p>
<pre>
void IMPORTER::ImportSceneMeshes(string szFileName, vector<CMesh*> &meshesImported, vector<int> &numMeshesForImportVector, vector<vector<TVector3>> &curvePointsImported,
								 vector<TVector3> &modelTranslation, vector<TVector3> &modelRotation, vector<TVector3>&modelScale)
{
	std::ifstream input;
	input.open(szFileName.c_str(), std::ios::binary | std::ios::in);

	if(input.is_open() == false)
		return;

	int nData = 0;
	int nMeshNameSize = 0;
	char szCharacter;
	string szMeshName;
	vector<string> vMeshNames;
	vector<vector<TVector3>> vvTranslateForSeq;
	vector<vector<TVector3>> vvRotateForSeq;
	vector<vector<TVector3>> vvScaleForSeq;

	// read the amount of items in the scene
	input.read((char*)&nData, sizeof(int));
	for(int i = 0; i < nData; i++)
	{
		// read the mesh name size
		szMeshName.clear();
		input.read((char*)&nMeshNameSize, sizeof(int));
		for(int j = 0; j < nMeshNameSize-1; j++)
		{
			input.read(&szCharacter, sizeof(char));
			szMeshName += szCharacter;
		}
		// read the null character
		input.read((char*)&szCharacter, sizeof(char));

		// while the last letter of the string is a number, delete until there are no numbers
		while(szMeshName[szMeshName.size()-1] >= 48 && szMeshName[szMeshName.size()-1] <= 57)
		{
			szMeshName.erase(szMeshName.size()-1);
		}

		bool bIsThere = false;

		for(unsigned w = 0; w < meshesImported.size(); w++)
		{
			if(vMeshNames[w] == szMeshName)
				bIsThere = true;
		}

		// if the mesh's string name is original, push back onto the stack and add a 1 to the numMeshesForImportVector
		// else, change that number at the subscript to add 1 more
		if(bIsThere == false)
		{
			vMeshNames.push_back(szMeshName);
			CMesh* newMesh;
			string szFullMeshPath = szFileName;
			while(szFullMeshPath[szFullMeshPath.size()-1] != '/')
				szFullMeshPath.erase(szFullMeshPath.size()-1);
			szFullMeshPath += szMeshName;
			szFullMeshPath += ".mesh";
			newMesh = IMPORTER::ImportMeshInfo(szFullMeshPath);
			meshesImported.push_back(newMesh);
			int newMeshNumber = 1;
			numMeshesForImportVector.push_back(newMeshNumber);

			// reading in the transforms for a completely new mesh
			TVector3 newTranslate;
			TVector3 newRotate;
			TVector3 newScale;

			// reading in the entire matrix
			double DTranslate[3];
			input.read((char*)&DTranslate, sizeof(double)*3);
			for(int d = 0; d < 3; d++)
				newTranslate.e[d] = (float)DTranslate[d];
			double DRotate[3];
			input.read((char*)&DRotate, sizeof(double)*3);
			for(int d = 0; d < 3; d++)
				newRotate.e[d] = (float)DRotate[d];
			double DScale[3];
			input.read((char*)&DScale, sizeof(double)*3);
			for(int d = 0; d < 3; d++)
				newScale.e[d] = (float)DScale[d];

			// make a new vector of TMatrix4's and push it onto the sequencing vector so it coincides with the meshes
			vector<TVector3> vNewTranslateVec;
			vector<TVector3> vNewRotateVec;
			vector<TVector3> vNewScaleVec;
			vNewTranslateVec.push_back(newTranslate);
			vNewRotateVec.push_back(newRotate);
			vNewScaleVec.push_back(newScale);
			vvTranslateForSeq.push_back(vNewTranslateVec);
			vvRotateForSeq.push_back(vNewRotateVec);
			vvScaleForSeq.push_back(vNewScaleVec);
		}
		else
		{
			for(unsigned int j = 0; j < meshesImported.size(); j++)
			{
				if(CGraphicsManager::GetInstance()->GetMesh(szMeshName)->GetName() == vMeshNames[j])
				{
					numMeshesForImportVector[j] = numMeshesForImportVector[j] + 1;
					// reading in the transforms for a mesh that's already there
					TVector3 newTranslate;
					TVector3 newRotate;
					TVector3 newScale;

					// reading in the entire matrix
					double DTranslate[3];
					input.read((char*)&DTranslate, sizeof(double)*3);
					for(int d = 0; d < 3; d++)
						newTranslate.e[d] = (float)DTranslate[d];
					double DRotate[3];
					input.read((char*)&DRotate, sizeof(double)*3);
					for(int d = 0; d < 3; d++)
						newRotate.e[d] = (float)DRotate[d];
					double DScale[3];
					input.read((char*)&DScale, sizeof(double)*3);
					for(int d = 0; d < 3; d++)
						newScale.e[d] = (float)DScale[d];

					// putting the matrices into contiguous mesh memory
					vvTranslateForSeq[j].push_back(newTranslate);
					vvRotateForSeq[j].push_back(newRotate);
					vvScaleForSeq[j].push_back(newScale);
					break;
				}
			}
		}
	}

	int numCVSets = 0;
	input.read((char*)&numCVSets, sizeof(unsigned int));
	curvePointsImported.resize(numCVSets);
	if(numCVSets != 0)
	{
		for(int j = 0; j < numCVSets; j++)
		{
			int sizeOfCVs = 0;
			// CURVES!
			input.read((char*)&sizeOfCVs, sizeof(unsigned int));
			if(sizeOfCVs != 0)
			{
				curvePointsImported[j].resize(sizeOfCVs);
				for(int i = 0; i < sizeOfCVs; i++)
				{
					double DVector[3];
					input.read((char*)&DVector, sizeof(double)*3);
					for(int d = 0; d < 3; d++)
					{
						curvePointsImported[j][i].x = (float)DVector[0];
						curvePointsImported[j][i].y = (float)DVector[1];
						curvePointsImported[j][i].z = (float)DVector[2];
					}
				}
			}
		}
	}

	// sequence the matrix vectors into one location for contiguity with the meshes vector
	for(unsigned int i = 0; i < meshesImported.size(); i++)
	{
		for(unsigned int j = 0; j < vvTranslateForSeq[i].size(); j++)
		{
			modelTranslation.push_back(vvTranslateForSeq[i][j]);
		}

		for(unsigned int j = 0; j < vvRotateForSeq[i].size(); j++)
		{
			modelRotation.push_back(vvRotateForSeq[i][j]);
		}

		for(unsigned int j = 0; j < vvScaleForSeq[i].size(); j++)
		{
			modelScale.push_back(vvScaleForSeq[i][j]);
		}
	}

	// close and clear the fstream
	input.close();
	input.clear();
}
</pre>